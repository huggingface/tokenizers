/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_SAFER-FFI-TOKENIZERS__
#define __RUST_SAFER-FFI-TOKENIZERS__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct FFITokenizer FFITokenizer_t;

/** \brief
 *  FFIResult is the FFI representation of Rust's Result type.
 * 
 *  Note: value and error cannot both be None at the same time, nor be Some at the same time.
 */
typedef struct {

    FFITokenizer_t * value;

    char * error;

} FFIResult_FFITokenizer_t;

FFIResult_FFITokenizer_t * tokenizer_from_pretrained (
    char const * ffi_identifier);


#include <stdbool.h>


#include <stddef.h>
#include <stdint.h>

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    int64_t * ptr;

    size_t len;

    size_t cap;

} Vec_int64_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    char * * ptr;

    size_t len;

    size_t cap;

} Vec_char_ptr_t;

/** \brief
 *  FFIEncoding is the FFI-representation of Encoding
 * 
 *  Fast tokenizers typically uses u32 for ids. Java however does not support unsigned integers
 *  as a primitive datatype natively. That's why those cases are converted to i64.
 * 
 *  For the cases an Option<u32> is returned, we map the None case to -1.
 */
typedef struct {

    Vec_int64_t ids;

    Vec_int64_t type_ids;

    Vec_char_ptr_t tokens;

    Vec_int64_t words;

} FFIEncoding_t;

/** \brief
 *  FFIResult is the FFI representation of Rust's Result type.
 * 
 *  Note: value and error cannot both be None at the same time, nor be Some at the same time.
 */
typedef struct {

    FFIEncoding_t * value;

    char * error;

} FFIResult_FFIEncoding_t;

FFIResult_FFIEncoding_t * encode_from_str (
    FFITokenizer_t const * it,
    char const * ffi_input,
    bool add_special_tokens);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    char const * * ptr;

    size_t len;

    size_t cap;

} Vec_char_const_ptr_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    FFIEncoding_t * * ptr;

    size_t len;

    size_t cap;

} Vec_FFIEncoding_ptr_t;

/** \brief
 *  FFIResult is the FFI representation of Rust's Result type.
 * 
 *  Note: value and error cannot both be None at the same time, nor be Some at the same time.
 */
typedef struct {

    Vec_FFIEncoding_ptr_t * value;

    char * error;

} FFIResult_Vec_FFIEncoding_ptr_t;

FFIResult_Vec_FFIEncoding_ptr_t * encode_batch (
    FFITokenizer_t const * it,
    Vec_char_const_ptr_t const * ffi_input,
    bool add_special_tokens);

void tokenizer_drop (
    FFIResult_FFITokenizer_t * ptr);

void encoding_drop (
    FFIResult_FFIEncoding_t * ptr);

void encodings_drop (
    FFIResult_Vec_FFIEncoding_ptr_t * ptr);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __RUST_SAFER-FFI-TOKENIZERS__ */
